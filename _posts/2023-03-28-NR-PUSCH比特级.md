---
layout: post
title:  "NR-PUSCH比特级"
author: "Geoffrey Hou"
comments: true
tags: NR
excerpt_separator: <!--more-->
sticky: true
hidden: true
---

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

学习R17的NR PUSCH比特级记录。<!--more-->

# UL-SCH

## CRC添加

### CRC计算

用$a_0, a_1, a_2, a_3, \cdots, a_{A-1}$表示输入bit序列，用$p_0, p_1, p_2, p_3, \cdots, p_{L-1}$表示校验bit序列。

校验bit序列可以通过下面几种循环生成多项式得到：

- $L=24$：
	- $g_{\mathrm{CRC} 24 \mathrm{~A}}(D)=\left[D^{24}+D^{23}+D^{18}+D^{17}+D^{14}+D^{11}+D^{10}+D^7+D^6+D^5+D^4+D^3+D+1\right]$（UL-SCH：$A>3824$）
	- $g_{\mathrm{CRC} 24 \mathrm{~B}}(D)=\left[D^{24}+D^{23}+D^6+D^5+D+1\right]$（UL-SCH：LDPC码块分割后的CRC添加）
	- $g_{\mathrm{CRC} 24 \mathrm{C}}(D)=\left[D^{24}+D^{23}+D^{21}+D^{20}+D^{17}+D^{15}+D^{13}+D^{12}+D^8+D^4+D^2+D+1\right]$（）
- $L=16$：
	- $g_{\mathrm{CRC} 16}(D)=\left[D^{16}+D^{12}+D^5+1\right]$（UL-SCH：$A \leq 3824$）
- $L=11$：
	- $g_{\mathrm{CRC} 11}(D)=\left[D^{11}+D^{10}+D^9+D^5+1\right]$（UCI：$A \geq 360$并且$E \geq 1088$ 或者 $A \geq 1013$）
- $L=6$：
	- $g_{\mathrm{CRC} 6}(D)=\left[D^6+D^5+1\right]$（UCI payload size：$12 \leq A \leq 19$）

用$b_0, b_1, b_2, b_3, \cdots, b_{B-1}$表示添加CRC后的bit序列，$B=A+L$。
$$
b_k=\left\{\begin{array}{l}a_k \text { for } k=0,1,2, \ldots, A-1 \\ p_{k-A} \text { for } k=A, A+1, A+2, \ldots, A+L-1\end{array}\right.
$$
UL-SCH根据输入bit序列长度选择生成多项式：
$$
g= \begin{cases}g_{\mathrm{CRC} 24 \mathrm{~A}}(D) & \text { for } A>3824 \\ g_{\mathrm{CRC} 16}(D) & \text { for } A \leq 3824\end{cases}
$$


## LPDC基图选择

$$
\text { base graph }= \begin{cases}\text { base graph 2, } & \text { for } A \leq 292, \text { or } A \leq 3824 \text { and } R \leq 0.67, \text { or } R \leq 0.25 \\ \text { base graph } 1, & \text { for otherwise }\end{cases}
$$

![](D:\Files\算法学习\PUSCH比特级\NR PUSCH比特级学习.assets\image-20230329100733327.png)



## 码块分割和码块CRC添加

码块分割的输入是添加CRC后的TB，用$b_0, b_1, b_2, b_3, \cdots, b_{B-1}$表示。

码块分割的输出用$c_{r 0}, c_{r 1}, c_{r 2}, c_{r 3}, \ldots, c_r\left(K_r-1\right)$，其中$0 \leq r<C$是码块索引，$K_r=K$是码块对应的比特数。



#### 确定最大码块大小

首先根据基图类型确定最大码块大小。

![image-20230331142050209](D:\Files\算法学习\PUSCH比特级\NR PUSCH比特级学习.assets\image-20230331142050209.png)



#### 确定码块个数

如果$B>K_{cb}$，需要先把输入bit序列分到不同码块中，然后对码块中的bit序列添加校验bit（使用$g_{\mathrm{CRC} 24 \mathrm{~B}}(D)$）；如果$B \leq K_{cb}$，输入bit序列作为一个码块，并且这里不需要添加CRC，因为前面整个TB已经添加过。

确定码块个数$C$。

![image-20230331141802112](D:\Files\算法学习\PUSCH比特级\NR PUSCH比特级学习.assets\image-20230331141802112.png)

码块长度包含校验bit，所以需要$K_{\mathrm{cb}}-L$，并且每个码块的有效bit数可能会小于最大码块大小，$B^{\prime}$是有效bit的总数。



#### 计算每个码块中的bit数

<a href="码块分割.pdf">码块分割具体步骤</a>



#### TBoMS

当行索引指示的TDRA中的*numberOfSlotsTBoMS*大于1时，也就是一个TB在多个slot上传输时，如果$R \leq 0.25$，那么$B \leq 3840$；否则，$B \leq 8448$。



## 信道编码

LDPC编码。前向纠错码。





## 速率匹配

编码之后的比特数和资源能承载的比特数可能不一致。如果资源较多，要选择哪些比特去发送；如果资源少，要选择哪些比特被去掉。用于对齐编码后的比特数和实际可用于传输的资源数量。

LPDC的速率匹配包括比特选择和比特交织。比特交织是为了对抗信道中的深衰进行的编码顺序的调换，不涉及数量的改变。比特选择的作用有如下解释：

1. 比特数和可用资源不匹配的原因

	- 发送端信道编码后会产生超量的校验比特，用于可能的HARQ重传。
	- 以下行接收为例，UE根据DCI得到码率、调制阶数、层数和资源分配等信息，确定TB Size。在计算可用的RE数量时，只考虑了时域符号数、DMRS占用资源和overhead。但是实际中可能存在更多的RE不能用于PDSCH，例如PT-RS、NZP/ZP CSI-RS等。

	所以，实际中每次传输，资源数确定的可用比特数晓宇编码比特数量，这样就需要在发送前把多出的比特去掉，来匹配实际的资源。

2. 匹配的方法

	每个码块信道编码后包含超量的校验比特。这样根据实际可传输的比特数$G$，决定每个码块可用的比特数，按照下面公式平均分配：
	$$
	E_r=N_L \cdot Q_m \cdot\left\lceil\frac{G}{N_L \cdot Q_m \cdot C^{\prime}}\right\rceil
	$$

3. 实际码率和overhead

	速率匹配不会影响信息比特payload，只影响一部分LDPC校验比特。

	但是实际码率会和MCS的码率不一致，尤其是有其他不可用于PDSCH的RE时，实际码率会升高，可靠性会降低。

	overhead在一定程度上调节不可用的RE。

4. 速率匹配的其他作用

	除了用来避免于NR本身的RS复用之外，协议还规定了其他几种方式，取消当前传输对资源的占用，通过抬升码率的方式避免干扰。

	- ServingCellConfig或 ServingCellConfigCommon中的RateMatchPattern字段，通过一个bitmap指示某个symbol上的某个PRB不能用于PDSCH传输。
	- Rel-15加入RateMatchPatternLTE-CRS通过将一个LTE小区的CRS配置（v-shift，port数，带宽，MBSFN配置）告知终端，来避免DSS场景下LTE常开的CRS对NR的干扰。
	- Rel-16扩展了上述配置，支持了对多个不同的LTE CRS进行速率匹配。





编码后的每个码块的bit用$d_{r 0}, d_{r 1}, d_{r 2}, d_{r 3}, \ldots, d_{r\left(N_r-1\right)}$表示，每个码块的bit被划分到不同的速率匹配块，$r$表示码块索引，$N_r$是码块上的编码后的比特数。总的码块个数用$C$表示。

如果资源分配表格中不存在*numberOfSlotsTBoMS*，或者资源分配表格中存在*numberOfSlotsTBoMS*但是行索引指示*numberOfSlotsTBoMS=1*，每个码块按照5.4.2独立进行速率匹配（如果*rateMatching*配置为*limitedBufferRM*，$I_{L B R M}=1$；否则$I_{L B R M}=0$）。

如果*numberOfSlotsTBoMS*>1，每个slot上的每个码块按照5.4.2独立进行速率匹配，并且满足以下设置：

- 如果*rateMatching*配置为*limitedBufferRM*，$I_{L B R M}=1$；否则$I_{L B R M}=0$。
- $G$作为slot中可用于TB传输的编码比特的总数。
- 对于TB processing over multiple slots，如果当前slot是这$N_s$个slot中的第一个slot，那么$K_0$按照$rv_{id}$和基图查表5.4.2.1-2得到，对不是第一个slot的slot，$k_0=\left(k_0^{\prime}+H+\tau\right) \bmod N_{c b}$。$N_s$表示*numberOfSlotsTBoMS*的值，$k_0^{\prime}$表示起始编码bit的索引（这$N_s$个slot中的上一个slot的），$H$是上一个slot可用的编码bit总数（假设没有UCI复用），$\tau$表示上一个slot跳过的填充比特数（见5.4.2.1，假设没有UCI复用）。

速率匹配后的比特序列用$f_{r 0}, f_{r 1}, f_{r 2}, f_{r 3}, \ldots, f_{r\left(E_r-1\right)}$，其中$E_r$是码块$r$的比特数。

### LDPC码的速率匹配

每个码块分别进行速率匹配，LDPC的速率匹配包括比特选择和比特交织。

速率匹配的输入用$d_0, d_1, d_2, \ldots, d_{N-1}$表示。

速率匹配的输出用$f_0, f_1, f_2, \ldots, f_{E-1}$表示。

#### 比特选择

比特交织的输入用$d_0, d_1, d_2, \ldots, d_{N-1}$表示。

比特交织的输出用$e_0, e_1, e_2, \ldots, e_{E-1}$表示。



输入比特序列被写入大小为$N_{cb}$的循环buffer中。

![image-20230331104809241](D:\Files\算法学习\PUSCH比特级\NR PUSCH比特级学习.assets\image-20230331104809241.png)

$T B S_{\mathrm{LBRM}}$根据214/6.1.4.2确定。



用$E_r$表示第$r$个码块的速率匹配输出长度。

![image-20230331133258579](D:\Files\算法学习\PUSCH比特级\NR PUSCH比特级学习.assets\image-20230331133258579.png)



用$r v_{i d}$表示冗余版本，$r v_{i d}=0,1,2,3$，比特交织的输出$e_k,k=0,1,2, \ldots, E-1$。

![image-20230331134419955](D:\Files\算法学习\PUSCH比特级\NR PUSCH比特级学习.assets\image-20230331134419955.png)

$k_0$的确定见下表。

![image-20230331134835589](D:\Files\算法学习\PUSCH比特级\NR PUSCH比特级学习.assets\image-20230331134835589.png)





##### TB size的确定

对于以下调度方式：

- PUSCH scheduled by RAR UL grant
- PUSCH scheduled by fallbackRAR UL grant
- PUSCH scheduled by a DCI format 0_0 with CRC scrambled by C-RNTI, MCS-C-RNTI, TC-RNTI, CS-RNTI
- PUSCH scheduled by a DCI format 0_1 or DCI format 0_2 with CRC scrambled by C-RNTI, MCS-C-RNTI, CS-RNTI
- PUSCH transmission with configured grant
- MsgA PUSCH transmission

如果，

- $0 \leq I_{M C S} \leq 27$，并且转换预编码不使能，并且使用Table 5.1.3.1-2
- 或者，$0 \leq I_{M C S} \leq 28$，并且转换预编码不使能，并且不使用Table 5.1.3.1-2
- 或者，$0 \leq I_{M C S} \leq 27$，并且转换预编码使能

那么，UE首先确定slot中的RE个数$N_{R E}$：

1. 确定一个PRB中分配给PUSCH的RE数：$N_{R E}^{\prime}=N_{s c}^{R B} \cdot N_{s y m b}^{s h}-N_{D M R S}^{P R B}-N_{o h}^{P R B}$。

2. 确定RE个数$N_{R E}$：

	- 如果是TB processing over multiple slots，$N_{R E}=N * \min \left(156, N_{R E}^{\prime}\right) \cdot n_{P R B}$。$N$是slot个数，等于高层参数值*numberOfSlotsTBoMS*。
	- 否则，$N_{R E}=\min \left(156, N_{R E}^{\prime}\right) \cdot n_{P R B}$。

3. 计算中间值$N_{\text {inf } o}=N_{R E} \cdot R \cdot Q_m \cdot v$。

	- 如果$N_{\text {inf } o} \leq 3824$，进行下一步。
	- 否则，进行下下一步。

4. 如果$N_{\text {inf } o} \leq 3824$，

	- 计算$N_{\text {info }}^{\prime}=\max \left(24,2^n \cdot\left\lfloor\frac{N_{\text {info }}}{2^n}\right\rfloor\right)$，$n=\max \left(3,\left\lfloor\log _2\left(N_{\inf o}\right)\right\rfloor-6\right)$。
	- 查找Table 5.1.3.2-1，找到不小于$N_{\inf o}^{\prime}$的最接近的TBS。

	![image-20230331160442364](D:\Files\算法学习\PUSCH比特级\NR PUSCH比特级学习.assets\image-20230331160442364.png)

5. 如果$N_{\text {inf } o}>3824$，

	- 计算$N_{\text {inf o }}^{\prime}=\max \left(3840,2^n \times \operatorname{round}\left(\frac{N_{\text {info }}-24}{2^n}\right)\right)$，$n=\left\lfloor\log _2\left(N_{\inf o}-24\right)\right\rfloor-5$。
	- ![image-20230331161353223](D:\Files\算法学习\PUSCH比特级\NR PUSCH比特级学习.assets\image-20230331161353223.png)

如果，

- $28 \leq I_{M C S} \leq 31$，并且转换预编码不使能，并且使用Table 5.1.3.1-2
- 或者，$28 \leq I_{M C S} \leq 31$，并且转换预编码使能

那么，假设TBS是根据使用$0 \leq I_{M C S} \leq 27$的相同TB的最新PDCCH中的DCI确定的；如果没有使用$0 \leq I_{M C S} \leq 27$相同TB的PDCCH，并且初始PUSCH通过configured grant发送，

- 对configured grant Type 1 PUSCH，TBS根据*configuredGrantConfig*确定。
- 对configured grant Type 2 PUSCH，TBS根据最新调度configured grant Type 2 PUSCH的PDCCH确定。

否则，假设TBS是根据使用$0 \leq I_{M C S} \leq 28$的相同TB的最新PDCCH中的DCI确定的；如果没有使用$0 \leq I_{M C S} \leq 28$相同TB的PDCCH，并且初始PUSCH通过configured grant发送，

- 对configured grant Type 1 PUSCH，TBS根据*configuredGrantConfig*确定。
- 对configured grant Type 2 PUSCH，TBS根据最新调度configured grant Type 2 PUSCH的PDCCH确定。





#### 比特交织

需要交织的原因：

- 实际环境中，如果有持续时间较长的衰落谷点，会影响到几个连续的比特，导致经常是成串发生比特差错。
- 信道编码只在检测和校正单个差错和不太长的差错串时才最有效。
- 交织可以分散这些误差，把长串比特差错变成短串差错，从而利用前向纠错码来纠错。

交织技术对已编码的信号按一定规则重新排列，解交织后突发性错误在时间上被分散，使其类似于独立发生的随机错误，从而前向纠错编码可以有效的进行纠错，前向纠错码加交积的作用可以理解为扩展了前向纠错的可抗长度字节。纠错能力强的编码一般要求的交织深度相对较低。纠错能力弱的则要求更深的交织深度。

一般来说，对数据进行传输时，在发端先对数据进行FEC编码，然后再进行交积处理。在收端次序和发端相反，先做去交积处理完成误差分散，再FEC解码实现数据纠错。



比特交织的输入用$e_0, e_1, e_2, \ldots, e_{E-1}$表示。

比特交织的输出用$f_0, f_1, f_2, \ldots, f_{E-1}$表示。

![image-20230331140239148](D:\Files\算法学习\PUSCH比特级\NR PUSCH比特级学习.assets\image-20230331140239148.png)



![image-20230331103539353](D:\Files\算法学习\PUSCH比特级\NR PUSCH比特级学习.assets\image-20230331103539353.png)



![image-20230331103448673](D:\Files\算法学习\PUSCH比特级\NR PUSCH比特级学习.assets\image-20230331103448673.png)



## 码块级联

码块级联的输入用$f_{r 0}, f_{r 1}, f_{r 2}, f_{r 3}, \ldots, f_{r\left(E_r-1\right)}$表示。

码块级联的输出用$g_0, g_1, g_2, g_3, \ldots, g_{G-1}$表示。



![image-20230331163407594](D:\Files\算法学习\PUSCH比特级\NR PUSCH比特级学习.assets\image-20230331163407594.png)



# 数据和UCI复用

有很多符号表示。

编码后的UL-SCH比特：$g_0^{\mathrm{UL}-\mathrm{SCH}}, g_1^{\mathrm{UL}-\mathrm{SCH}}, g_2^{\mathrm{UL}-\mathrm{SCH}}, g_3^{\mathrm{UL}-\mathrm{SCH}}, \ldots, g_{G^{\mathrm{UL}-\mathrm{SCH}}-1}^{\mathrm{UL-SCH}}$。

编码后的HARQ-ACK比特，或者（如果配置了*cg-UCI-Multiplexing*）HARQ-ACK和CG-UCI联合编码后的比特：$g_0^{\mathrm{ACK}}, g_1^{\mathrm{ACK}}, g_2^{\mathrm{ACK}}, g_3^{\mathrm{ACK}}, \ldots, g_{G^{\mathrm{ACK}}-1}^{\mathrm{ACK}}$。

编码后的CSI part 1（如果有）：$g_0^{\text {CSI-part1 }}, g_1^{\text {CSI-part1 }}, g_2^{\text {CSI-part1 }}, g_3^{\text {CSI-part1 }}, \ldots, g_{G^{\text {CSI-part1}}-1}^{\text {CSI-part1}}$。

编码后的CSI part 2（如果有）：$g_0^{\text {CSI-part2 }}, g_1^{\text {CSI-part2 }}, g_2^{\text {CSI-part2 }}, g_3^{\text {CSI-part2 }}, \ldots, g_{G^{\text {CSI-part2}}-1}^{\text {CSI-part2}}$。

编码后的CG-UCI（没有HARQ-ACK）：$\mathrm{g}_0^{\text {CG-UCI }}, \mathrm{g}_1^{\text {CG-UCI }}, \mathrm{g}_2^{\text {CG-UCI }}, \mathrm{g}_3^{\text {CG-UCI }}, \ldots, \mathrm{g}_{G^{C G-U C I}-1}^{\text {CG-UI }}$。

数据和UCI复用后的比特：$g_0, g_1, g_2, g_3, \ldots, g_{G-1}$。



$l$表示PUSCH的符号索引，从0开始到$N_{\text {symb,all }}^{\mathrm{PUSCH}}-1$。$N_{\text {symb,all }}^{\mathrm{PUSCH}}$是PUSCH的总符号数，包括DMRS占用的符号。

$k$表示PUSCH的子载波索引，从0开始到$M_{\mathrm{sc}}^{\mathrm{PUSCH}}-1$。$M_{\mathrm{sc}}^{\mathrm{PUSCH}}$是子载波总数。

$\Phi_l^{\mathrm{UL}-\mathrm{SCH}}$表示符号$l$上可以给UL-SCH用的RE的集合，以$k$的升序表示，$l=0,1,2, \ldots, N_{\text {symb,all }}^{\mathrm{PUSCH}}-1$。

$M_{\mathrm{sc}}^{\mathrm{UL}-\mathrm{SCH}}(l)=\left|\Phi_l^{\mathrm{UL}-\mathrm{SCH}}\right|$是集合$\left|\Phi_l^{\mathrm{UL}-\mathrm{SCH}}\right|$中的元素个数，$\Phi_l^{\mathrm{UL}-\mathrm{SCH}}(j)$表示第$j$个元素。

$\Phi_l^{\mathrm{UCI}}$表示符号$l$上可以给UCI用的RE的集合，以$k$的升序表示，$l=0,1,2, \ldots, N_{\text {symb,all }}^{\mathrm{PUSCH}}-1$。

$M_{\mathrm{sc}}^{\mathrm{UCI}}(l)=\left|\Phi_l^{\mathrm{UCI}}\right|$是集合中的元素个数。$\Phi_l^{\mathrm{UCI}}(j)$表示第$j$个元素。

在DMRS的符号上的RE不能UCI用，$\Phi_l^{\mathrm{UCI}}=\varnothing$。

在没有DMRS的符号上的RE由UL-SCH和UCI平分，$\Phi_l^{\mathrm{UCI}}=\Phi_l^{\mathrm{UL}-\mathrm{SCH}}$。



如果配置跳频：

- $l^{(1)}$表示第一跳中有DMRS的第一个连续符号集合后的第一个符号的索引。
- $l^{(2)}$表示第二跳中有DMRS的第一个连续符号集合后的第一个符号的索引。
- $l_{\mathrm{CSI}}^{(1)}$表示第一跳中没有DMRS的第一个符号索引。
- $l_{\mathrm{CSI}}^{(2)}$表示第二跳中没有DMRS的第一个符号索引。
- 如果有HARQ-ACK和UL-SCH，或者UL-SCH、HARQ-ACK和CG-UCI都有：
	- $G^{\mathrm{ACK}}(1)=N_L \cdot Q_m \cdot\left\lfloor G^{\mathrm{ACK}} /\left(2 \cdot N_L \cdot Q_m\right)\right\rfloor$，$G^{\mathrm{ACK}}(2)=N_L \cdot Q_m \cdot\lceil G^{\mathrm{ACK}} /\left(2 \cdot N_L \cdot Q_m\right)\rceil$。
- 如果有CSI和UL-SCH：
	- $G^{\text {CSI-part1 }}(1)=N_L \cdot Q_m \cdot\left\lfloor G^{\text {CSI-part1 }} /\left(2 \cdot N_L \cdot Q_m\right)\right\rfloor$。
	- $G^{\text {CSI-part1 }}(2)=N_L \cdot Q_m \cdot\left\lceil G^{\text {CSI-part1 }} /\left(2 \cdot N_L \cdot Q_m\right)\right\rceil$。
	- $G^{\text {CSI-part2 }}(1)=N_L \cdot Q_m \cdot\left\lfloor G^{\text {CSI-part1 }} /\left(2 \cdot N_L \cdot Q_m\right)\right\rfloor$。
	- $G^{\text {CSI-part2 }}(2)=N_L \cdot Q_m \cdot\left\lceil G^{\text {CSI-part1 }} /\left(2 \cdot N_L \cdot Q_m\right)\right\rceil$。
- 如果有CG-UCI，没有HARQ-ACK：
	- $G^{C G-U C I}(1)=N_L \cdot Q_m \cdot\left\lfloor G^{C G-U C I} /\left(2 \cdot N_L \cdot Q_m\right)\right\rfloor$，$G^{C G-U C I}(2)=N_L \cdot Q_m \cdot\left\lceil G^{C G-U C I} /\left(2 \cdot N_L \cdot Q_m\right)\right\rceil$。
- 如果只有HARQ-ACK和CSI part 1，没有UL-SCH：
	- $G^{\mathrm{ACK}}(1)=\min \left(N_L \cdot Q_m \cdot\left\lfloor G^{\mathrm{ACK}} /\left(2 \cdot N_L \cdot Q_m\right)\right\rfloor, M_3 \cdot N_L \cdot Q_m\right)$。
	- $G^{\mathrm{ACK}}(2)=G^{\mathrm{ACK}}-G^{\mathrm{ACK}}(1)$。
	- $G^{\text {CSI-part1 }}(1)=M_1 \cdot N_L \cdot Q_m-G^{\mathrm{ACK}}(1)$。
	- $G^{\text {CSI-part1 }}(2)=G^{\text {CSI-part1 }}-G^{\text {CSI-part1 }}(1)$。
- 如果有HARQ-ACK、CSI part 1和CSI part 2，没有UL-SCH：
	- $G^{\mathrm{ACK}}(1)=\min \left(N_L \cdot Q_m \cdot\left\lfloor G^{\mathrm{ACK}} /\left(2 \cdot N_L \cdot Q_m\right)\right\rfloor, M_3 \cdot N_L \cdot Q_m\right)$。
	- $G^{\mathrm{ACK}}(2)=G^{\mathrm{ACK}}-G^{\mathrm{ACK}}(1)$。
	- 如果HAR-ACK的信息比特数大于2，$G^{\text {CSI-part1 }}(1)=\min \left(N_L \cdot Q_m \cdot\left\lfloor G^{\text {CSI-part1 }} /\left(2 \cdot N_L \cdot Q_m\right)\right\rfloor, M_1 \cdot N_L \cdot Q_m-G^{\text {ACK }}(1)\right)$；否则，$G^{\mathrm{CSI}-\mathrm{part1}}(1)=\min \left(N_L \cdot Q_m \cdot\left[G^{\mathrm{CSI}-\mathrm{part1}} /\left(2 \cdot N_L \cdot Q_m\right)\right\rfloor, M_1 \cdot N_L \cdot Q_m-G_{r v d}^{\mathrm{ACK}}(1)\right)$。
	- $G^{\text {CSI-part1 }}(2)=G^{\text {CSI-part1 }}-G^{\text {CSI-part1 }}(1)$。
	- 如果HAR-ACK的信息比特数不超过2，$G^{\text {CSI-part2 }}(1)=M_1 \cdot N_L \cdot Q_m-G^{\text {CSI-part1 }} (1)$；否则，$G^{\text {CSI-part2 }}(1)=M_1 \cdot N_L \cdot Q_m-G^{\mathrm{ACK}}(1)-G^{\mathrm{CSI}-\mathrm{part1}}(1)$。
	- 如果HAR-ACK的信息比特数不超过2，$G^{\mathrm{CSI}-\mathrm{pat2}}(2)=M_2 \cdot N_L \cdot Q_m-G^{\mathrm{CSI}-\mathrm{part1}}(2)$；否则，$G^{\text {CSI-part } 2}(2)=M_2 \cdot N_L \cdot Q_m-G^{\text {ACK }}(2)-G^{\mathrm{CSI}-\mathrm{part1}}(2)$。
- 如果有CSI part 1和CSI part 2，没有UL-SCH：
	- $G^{\mathrm{CSI}-\mathrm{part1}}(1)=\min \left(N_L \cdot Q_m \cdot\lfloor G^{\mathrm{CSI}-\mathrm{part1}} /\left(2 \cdot N_L \cdot Q_m\right)\rfloor, M_1 \cdot N_L \cdot Q_m-G_{r v d}^{\mathrm{ACK}}(1)\right)$。
	- $G^{\text {CSI-part1 }}(2)=G^{\text {CSI-part1 }}-G^{\text {CSI-part1 }}(1)$。
	- $G^{\text {CSI-part2 }}(1)=M_1 \cdot N_L \cdot Q_m-G^{\text {CSI-part1 }}$ (1)。
	- $G^{\mathrm{CSI}-\mathrm{part2}}(2)=M_2 \cdot N_L \cdot Q_m-G^{\mathrm{CSI}-\mathrm{part1}}(2)$。
- $N_{\text {hop }}^{\mathrm{PUSCH}}=2$，用$N_{\text {symb,hop }}^{\mathrm{PUSCH}}(1), \quad N_{\text {symb,hop }}^{\mathrm{PUSCH}}(2)$分别表示第一跳和第二跳的符号数。
- $N_L$是层数。
- $Q_m$是调制阶数。
- $M_1=\sum^{l = N_{\text{symb,hop}}^{\text{PUSCH}}(1)-1}_{l = 0}{M_{SC}^{UCI}(l)}$。
- $M_2=\sum^{l = N_{\text{symb,hop}}^{\text{PUSCH}}(1)+N_{\text{symb,hop}}^{\text{PUSCH}}(2)-1}_{l = N_{\text{symb,hop}}^{\text{PUSCH}}(1)}{M_{SC}^{UCI}(l)}$。
- $M_3=\sum^{l = N_{\text{symb,hop}}^{\text{PUSCH}}(1)-1}_{l = l^{(1)}}{M_{SC}^{UCI}(l)}$。



如果不跳频：

- $l^{(1)}$表示为有DMRS的第一组连续符号之后的第一个符号的索引。
- $l_{\mathrm{CSI}}^{(1)}$表示没有DMRS的第一个符号的索引。
- 如果有HARQ-ACK和UL-SCH，或者UL-SCH、HARQ-ACK和CG-UCI都有：
	- $G^{\mathrm{ACK}}(1)=G^{\mathrm{ACK}}$。
- 如果有CSI：
	- $G^{\text {CSI-part1 }}(1)=G^{\text {CSI-part1 }}$，$G^{\text {CSI-part2 }}(1)=G^{\text {CSI-part2 }}$。
- 如果有CG-CSI，没有HARQ-ACK：
	- $G^{\mathrm{CG}-\mathrm{UCI}}(1)=G^{\mathrm{CG}-\mathrm{UCI}}$。
- $N_{\text {hop }}^{\mathrm{PUSCH}}=1$，$N_{\text {symb,hop }}^{\text {PUSCH }}(1)=N_{\text {symb,all }}^{\text {PUSCH }}$。





有了上面符号，按照212/6.2.7中UL-SCH和UCI复用的步骤，得到输出$g_0, g_1, g_2, g_3, \ldots, g_{G-1}$。

<a href="UCI复用.pdf">UCI复用具体步骤</a>
